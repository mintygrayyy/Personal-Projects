**READ ME**

    In our code, we decided to utilize the controller, model, and view designs in order to implement
our image filters. Similar to marble solitaire, there were many instances where we needed to be able
to take in a command from the user and output it in our code, so we though this would be useful
for displaying and modifying our images as well.
    The Image class represents our image in the form of a 2D pixel array, similar to the Image class
in the SFML library of C++. The getPixelArray function grabs the pixel array of the image so it can
be modified. The filterCopy method filters a copy of the image because the original image cannot be
modified.
    The Pixel class represents a single pixel in the array. Taking inspiration from C++, the pixel
class has three separate RGB values that are modified in order to create the filter effect.
    In addition, our code uses the factory pattern to apply the filters on the pictures from the
controller. The FilterFactory interface has one function that applies the filter to the input image.
Each class in the filter package represents a different filter and implements the FilterFactory
interface and inherits the method so each class applies its specific filter to the image taken in.
    The controller interface and implementation are in charge of taking in inputs from the user and
telling the View what to output by rendering messages. The controller uses a switch statement to track
all the input possibilities based on the user's input. Since the filters also cannot be applied on
the original image, the controller creates a new function, filter, that creates a copy of the original
image and modifies it instead.
    The model is the model of the image processor that has the filters applied to it to
output the new image. Our model class utilizes a hashmap to store the name of the image as well as
the image file itself. By utilizing a hashmap, we have access to the put() function that allows us
to assign the input image to a filename which we use later to modify that specific image. The
findImage function also allows the model class to make sure the file the user input actually exists.
The applyFilter method applies the given filter to the copy made of the image.
    The view class output the model of our image. Once an image has been correctly loaded, saved, or
modified, the view class would output a message that lets the user know their filter has been run
successfully. Similar to marble solitaire, we have implemented a renderMessage method that allows us
to send the message to the view.

    We implemented the blur and sharpen filters by creating a new kernel filter abstract class that
both filters extend. The abstract class calls the method "convolution" from the pixel class to apply
the desired kernel onto the pixel array of the image. We could not hard code the kernels within the
abstract class because both the blur and sharpen kernels are different sizes, so we had to come up
with a way for us to apply both types of kernels without limiting the kernel size. Both filters take
a  bit of time to run, so there is a bit of waiting involved while the filter applies.
    To implement greyscale and sepia filters, we added another abstract class called Color that
takes in a 3x3 2D array that maps onto the specific RGB values of the pixel array through a method
called "color" in the pixel class.


The test.ppm file used as our example is a ppm file created by Mike Shah of his headshot.

Script of commands:
Please type all commands in the command line when the program is run.
to load image: load res\test.ppm test
red filter: red test redtest
green filter: green test greentest
blue filter: blue test bluetest
brighten: brighten 10 test brightentest
darken: darken 10 test darkentest
intensity: intensity test intensitytest
luma: luma test lumatest
value: value test valuetest
horizontal fip: horizontal test horizontaltest
vertical flip: vertical test verticaltest
save: save res\testblue.ppm bluetest
